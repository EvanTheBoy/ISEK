from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, List, Optional, Union
from uuid import uuid4

from isek.agent.isek.agent import Agent
from isek.memory.memory import Memory
from isek.models.base import Model, SimpleMessage
from isek.team.base import Team, TeamCard
from isek.tools.toolkit import Toolkit
from isek.utils.log import log_debug, set_log_level_to_debug


@dataclass
class IsekTeam(Team):
    """Ultra-simplified Team class that coordinates multiple agents."""

    # List of team members (agents or other teams) - required field
    members: List[Union[Agent, "IsekTeam"]]
    # Team name
    name: Optional[str] = None
    # Team UUID (autogenerated if not set)
    team_id: Optional[str] = None
    # Model for this Team (used for coordination)
    model: Optional[Model] = None
    # Team memory
    memory: Optional[Memory] = None
    # Tools provided to the Team model
    tools: Optional[List[Toolkit]] = None
    # A description of the Team
    description: Optional[str] = None
    # Success criteria for the task
    success_criteria: Optional[str] = None
    # List of instructions for the team
    instructions: Optional[Union[str, List[str], Callable]] = None
    # Team mode: "route", "coordinate", or "collaborate"
    mode: str = "coordinate"
    # Enable debug logs
    debug_mode: bool = False

    def __post_init__(self):
        """Initialize the team after creation."""
        # Set team ID if not provided
        if self.team_id is None:
            self.team_id = str(uuid4())

        # Set debug mode
        if self.debug_mode:
            set_log_level_to_debug()
            log_debug(
                f"Team initialized: {self.name or 'Unnamed'} (ID: {self.team_id})"
            )
            log_debug(f"Team mode: {self.mode}")
            log_debug(f"Number of members: {len(self.members)}")

    def run(self, prompt: str) -> str:
        """
        Runs the team with a simple prompt.
        For node-based interaction, this simplifies the interface.
        It defaults to using the 'coordinate' mode for multi-agent response.
        """
        if not self.members:
            raise ValueError("Team must have at least one member")

        if self.debug_mode:
            log_debug(f"Team run started with prompt: {prompt}")

        # For simplicity, we delegate to the first member if there's only one.
        if len(self.members) == 1 and isinstance(self.members[0], Agent):
            return self.members[0].run(
                prompt, user_id="node_user", session_id=str(uuid4())
            )

        # If multiple members, use the coordinate mode logic.
        return self._run_coordinate_mode(prompt, "node_user", str(uuid4()))

    def get_team_card(self) -> TeamCard:
        """
        Provide metadata about the team for discovery purposes.
        """
        routine_str = ""
        if isinstance(self.instructions, list):
            routine_str = "\n".join(self.instructions)
        elif isinstance(self.instructions, str):
            routine_str = self.instructions

        return TeamCard(
            name=self.name or "Unnamed Team",
            bio=self.description or "No description",
            lore="This is a team of agents.",
            knowledge="",  # Knowledge is specific to agents, so leave blank for team.
            routine=routine_str,
        )

    def _run_route_mode(self, message: str, user_id: str, session_id: str) -> str:
        """Route the message to the most appropriate team member."""
        if self.model is None:
            # Simple routing: use the first member
            member = self.members[0]
            if isinstance(member, Agent):
                return member.run(message, user_id, session_id)
            else:  # It's a IsekTeam
                return member.run(message)

        # Use the team model to decide which member to route to
        routing_prompt = self._build_routing_prompt(message)

        messages = [
            SimpleMessage(role="system", content=routing_prompt),
            SimpleMessage(role="user", content=message),
        ]

        response = self.model.response(messages=messages)
        routing_decision = response.content or ""

        if self.debug_mode:
            log_debug(f"Routing decision: {routing_decision}")

        # Simple routing logic: route to first member for now
        # In a more sophisticated implementation, you'd parse the routing decision
        member = self.members[0]
        if isinstance(member, Agent):
            return member.run(message, user_id, session_id)
        else:  # It's a IsekTeam
            return member.run(message)

    def _run_coordinate_mode(self, message: str, user_id: str, session_id: str) -> str:
        """Coordinate team members to work together on the task."""
        if self.model is None:
            # Simple coordination: run all members and combine results
            results = []
            for member in self.members:
                try:
                    if isinstance(member, Agent):
                        result = member.run(message, user_id, session_id)
                    else:  # It's a IsekTeam
                        result = member.run(message)
                    results.append(f"{member.name or 'Member'}: {result}")
                except Exception as e:
                    if self.debug_mode:
                        log_debug(f"Member {member.name or 'Unknown'} failed: {e}")
                    results.append(f"{member.name or 'Member'}: Error - {str(e)}")

            return "\n\n".join(results)

        # Use the team model to coordinate the work
        coordination_prompt = self._build_coordination_prompt(message)

        messages = [
            SimpleMessage(role="system", content=coordination_prompt),
            SimpleMessage(role="user", content=message),
        ]

        # Add tools for running team members if available
        tools_param = None
        if self.tools:
            tools_param = []
            for toolkit in self.tools:
                for func in toolkit.functions.values():
                    tools_param.append({"type": "function", "function": func.to_dict()})

        response = self.model.response(
            messages=messages, tools=tools_param, toolkits=self.tools or []
        )

        return response.content or "No coordination response generated"

    def _run_collaborate_mode(self, message: str, user_id: str, session_id: str) -> str:
        """Have team members collaborate on the task."""
        # Run all members and let them build on each other's responses
        conversation_history = [message]

        for i, member in enumerate(self.members):
            # Build context from previous responses
            context = "\n".join(conversation_history)

            # Add collaboration instruction
            collaboration_message = f"""Previous team discussion:
{context}

Please contribute to this collaborative discussion. Build on previous responses and add your expertise."""

            try:
                if isinstance(member, Agent):
                    response = member.run(collaboration_message, user_id, session_id)
                else:  # It's a IsekTeam
                    response = member.run(collaboration_message)
                conversation_history.append(
                    f"{member.name or f'Member {i+1}'}: {response}"
                )
            except Exception as e:
                if self.debug_mode:
                    log_debug(f"Member {member.name or 'Unknown'} failed: {e}")
                conversation_history.append(
                    f"{member.name or f'Member {i+1}'}: Error - {str(e)}"
                )

        # Return the final collaborative response
        return "\n\n".join(conversation_history)

    def _build_routing_prompt(self, message: str) -> str:
        """Build the routing prompt for the team model."""
        parts = []

        if self.description:
            parts.append(f"Team Description: {self.description}")

        parts.append(
            "You are a team coordinator. Your job is to route the user's request to the most appropriate team member."
        )
        parts.append(f"Available team members: {len(self.members)}")

        for i, member in enumerate(self.members):
            member_desc = member.description or f"Team member {i+1}"
            parts.append(f"- Member {i+1}: {member_desc}")

        if self.instructions:
            if isinstance(self.instructions, str):
                parts.append(f"Routing Instructions: {self.instructions}")
            elif isinstance(self.instructions, list):
                parts.append("Routing Instructions:")
                for instruction in self.instructions:
                    parts.append(f"- {instruction}")
            elif callable(self.instructions):
                parts.append(f"Routing Instructions: {self.instructions()}")

        parts.append(
            "Please analyze the user's request and determine which team member should handle it."
        )

        return "\n".join(parts)

    def _build_coordination_prompt(self, message: str) -> str:
        """Build the coordination prompt for the team model."""
        parts = []

        if self.description:
            parts.append(f"Team Description: {self.description}")

        parts.append(
            "You are a team coordinator. Your job is to coordinate the team members to work together on the user's request."
        )
        parts.append(f"Available team members: {len(self.members)}")

        for i, member in enumerate(self.members):
            member_desc = member.description or f"Team member {i+1}"
            parts.append(f"- Member {i+1}: {member_desc}")

        if self.success_criteria:
            parts.append(f"Success Criteria: {self.success_criteria}")

        if self.instructions:
            if isinstance(self.instructions, str):
                parts.append(f"Coordination Instructions: {self.instructions}")
            elif isinstance(self.instructions, list):
                parts.append("Coordination Instructions:")
                for instruction in self.instructions:
                    parts.append(f"- {instruction}")
            elif callable(self.instructions):
                parts.append(f"Coordination Instructions: {self.instructions()}")

        parts.append(
            "Please coordinate the team members to complete the user's request effectively."
        )

        return "\n".join(parts)

    def add_member(self, member: Union[Agent, "IsekTeam"]) -> None:
        """Add a member to the team."""
        self.members.append(member)
        if self.debug_mode:
            log_debug(f"Added member to team: {member.name or 'Unnamed'}")

    def remove_member(self, member: Union[Agent, "IsekTeam"]) -> bool:
        """Remove a member from the team."""
        try:
            self.members.remove(member)
            if self.debug_mode:
                log_debug(f"Removed member from team: {member.name or 'Unnamed'}")
            return True
        except ValueError:
            return False

    def get_member_by_name(self, name: str) -> Optional[Union[Agent, "IsekTeam"]]:
        """Get a team member by name."""
        for member in self.members:
            if member.name == name:
                return member
        return None

    def __repr__(self) -> str:
        return f"IsekTeam(name='{self.name}', id='{self.team_id}', members={len(self.members)}, mode='{self.mode}')"
