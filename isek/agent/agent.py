from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, List, Optional, Union
from uuid import uuid4

from isek.memory.memory import Memory, UserMemory
from isek.models.base import Model, SimpleMessage
from isek.tools.toolkit import Toolkit
from isek.utils.log import log_debug, set_log_level_to_debug


@dataclass
class Agent:
    """Ultra-simplified Agent class with minimal features."""

    # Agent name
    name: Optional[str] = None
    # Agent UUID (autogenerated if not set)
    agent_id: Optional[str] = None
    # Model for this Agent
    model: Optional[Model] = None
    # Agent memory
    memory: Optional[Memory] = None
    # Tools provided to the Model
    tools: Optional[List[Toolkit]] = None
    # A description of the Agent
    description: Optional[str] = None
    # Success criteria for the task
    success_criteria: Optional[str] = None
    # List of instructions for the agent
    instructions: Optional[Union[str, List[str], Callable]] = None
    # Enable debug logs
    debug_mode: bool = False

    def __post_init__(self):
        """Initialize the agent after creation."""
        # Set agent ID if not provided
        if self.agent_id is None:
            self.agent_id = str(uuid4())

        # Set debug mode
        if self.debug_mode:
            set_log_level_to_debug()
            log_debug(
                f"Agent initialized: {self.name or 'Unnamed'} (ID: {self.agent_id})"
            )

    def run(
        self, message: str, user_id: str = "default", session_id: Optional[str] = None
    ) -> str:
        """Run the agent with a message and return the response."""
        if self.model is None:
            raise ValueError("Model is required to run the agent")

        # Generate session ID if not provided
        if session_id is None:
            session_id = str(uuid4())

        # Create system message from agent configuration
        system_message = self._build_system_message()

        # Get relevant memories if memory is available
        memory_context = self._get_memory_context(user_id)

        # Gather tool schemas if tools are present
        tools_param = None
        if self.tools:
            tools_param = []
            for toolkit in self.tools:
                for func in toolkit.functions.values():
                    tools_param.append({"type": "function", "function": func.to_dict()})

        # Conversation history
        messages = []
        if system_message and system_message != "You are a helpful AI assistant.":
            messages.append(SimpleMessage(role="system", content=system_message))
        if memory_context:
            messages.append(
                SimpleMessage(
                    role="system", content=f"Previous context:\n{memory_context}"
                )
            )
        messages.append(SimpleMessage(role="user", content=message))

        # Call the model - it will handle tool calling internally
        response = self.model.response(
            messages=messages,
            tools=tools_param,
            toolkits=self.tools or [],  # Pass actual toolkits for execution
        )

        response_content = response.content or "No response generated"

        # Store in memory if available
        if self.memory:
            self._store_conversation(user_id, session_id, message, response_content)

        if self.debug_mode:
            log_debug(f"Session ID: {session_id}")
            log_debug(f"User ID: {user_id}")
            log_debug(f"System message: {system_message}")
            log_debug(f"Memory context: {memory_context}")
            log_debug(f"User message: {message}")
            log_debug(f"Model response: {response_content}")
            if tools_param:
                log_debug(f"Tools: {tools_param}")

        return response_content

    def _get_memory_context(self, user_id: str) -> Optional[str]:
        """Get relevant memory context for the user."""
        if not self.memory:
            return None

        memories = self.memory.get_user_memories(user_id)
        if not memories:
            return None

        # For now, include all memories (in a real implementation, you might want to filter by relevance)
        memory_texts = []
        for memory in memories:
            memory_texts.append(f"- {memory.memory}")

        return "Previous interactions:\n" + "\n".join(memory_texts)

    def _store_conversation(
        self, user_id: str, session_id: str, user_message: str, agent_response: str
    ) -> None:
        """Store the conversation in memory."""
        if not self.memory:
            return

        # Store user memory
        user_memory = UserMemory(
            memory=f"User: {user_message}\nAgent: {agent_response}",
            topics=["conversation"],
        )
        self.memory.add_user_memory(user_memory, user_id)

        # Store run
        run_data = {
            "user_message": user_message,
            "agent_response": agent_response,
            "timestamp": str(uuid4()),  # Simple timestamp for now
        }
        self.memory.add_run(session_id, run_data)

        if self.debug_mode:
            log_debug(
                f"Stored conversation in memory for user {user_id}, session {session_id}"
            )

    def _build_system_message(self) -> str:
        """Build the system message from agent configuration."""
        parts = []

        if self.description:
            parts.append(f"Description: {self.description}")

        if self.success_criteria:
            parts.append(f"Success Criteria: {self.success_criteria}")

        if self.instructions:
            if isinstance(self.instructions, str):
                parts.append(f"Instructions: {self.instructions}")
            elif isinstance(self.instructions, list):
                parts.append("Instructions:")
                for instruction in self.instructions:
                    parts.append(f"- {instruction}")
            elif callable(self.instructions):
                parts.append(f"Instructions: {self.instructions()}")

        return "\n".join(parts) if parts else "You are a helpful AI assistant."

    def __repr__(self) -> str:
        return f"Agent(name='{self.name}', id='{self.agent_id}')"
